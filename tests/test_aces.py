import sys
sys.path.insert(1, "./")
import pyaces as pyc

"""
Test for the Repartition and ACES encryption and decryption functionality in the pyaces module.

This test demonstrates the functionality of the following components:
1. Repartition class: Initialize with parameters `n`, `p`, and `upperbound`, and construct the repartition structure.
2. ArithChannel class: Initialize an arithmetic channel using the repartition instance, and verify the cryptographic parameter publication.
3. ACES encryption and decryption: Perform encryption and decryption operations using both Alice's and Bob's encryption systems, ensuring that the expected results match.
4. Refresher mechanisms: Verify that the refresher generated by Alice and Bob is of the correct dimension and structure.

Inputs:
- n: Number of levels for the Repartition.
- p: A prime number used in the arithmetic channel.
- upperbound: The upper bound for generating primes.
- public: The cryptographic parameters published by the arithmetic channel.
- max_noise: The maximum allowed noise during encryption for Alice's and Bob's encryption.

Outputs:
- Verification of the construction of cryptographic parameters and correct encryption/decryption results.
- Refresher structures are validated for correctness in terms of dimensions and encryption objects.
"""

# Step 1: Initialize a Repartition instance and construct the structure
repartition = pyc.Repartition(n=5, p=2, upperbound=47601551)
repartition.construct()

# Step 2: Initialize an arithmetic channel using the Repartition instance
ac = pyc.ArithChannel(p=32, N=10, deg_u=3, repartition=repartition)

# Step 3: Generate and publish cryptographic parameters
public = ac.publish(publish_levels=True)
print("Levels used in public key =", public["levels"])
assert len(public["levels"]) == 10, f"Error in ArithChannel.publish(): Number of levels is not equal to N={10}"

# Step 4: Check polynomial u for particular conditions
u: pyc.Polynomial = public["u"]
print("Polynomial u(X):", u)
assert u(1) == 0 and u.lead_coef() == 1, "Error in publish()"

# Step 5: Set up Alice's system with debug to track noise levels
alice = pyc.ACESReader(ac, debug=True)

# Step 6: Set up Bob's system with debug to track noise levels
bob = pyc.ACES(**public, debug=True)

# Step 7: Encrypt and decrypt using Bob's system
print("\nbob encrypts 3:")
cip3 = bob.encrypt(3)
print("Associated level:", cip3.lvl)
assert isinstance(cip3, pyc.ACESCipher) and alice.decrypt(cip3) == 3, "Error in ACES.encrypt()"

print("\nbob encrypts 5:")
cip5 = bob.encrypt(37)
print("Associated level:", cip5.lvl)
assert isinstance(cip5, pyc.ACESCipher) and alice.decrypt(cip5) == 5, "Error in ACES.encrypt()"

# Step 8: Encrypt and decrypt using Alice's system
print("\nalice encrypts 3:")
cip3 = alice.encrypt(3, max_noise=10)
print("Associated level:", cip3.lvl)
assert isinstance(cip3, pyc.ACESCipher) and alice.decrypt(cip3) == 3, "Error in ACESReader.encrypt()"

print("\nalice encrypts 5:")
cip5 = alice.encrypt(37, max_noise=10)
print("Associated level:", cip5.lvl)
assert isinstance(cip5, pyc.ACESCipher) and alice.decrypt(cip5) == 5, "Error in ACESReader.encrypt()"

# Step 9: Test Alice's refresher generation
print("\n~~~~ alice refresher ~~~~")
refresher = alice.generate_refresher(max_noise=10)
assert len(refresher) == 5, f"Error in ACESReader.generate_refresher(): refresher dimension is not equal to n={5}"

for r in refresher:
    print(f"Level: {r.lvl}, with encryption:", r.enc)
    assert isinstance(r, pyc.ACESCipher), "Error in ACESReader.generate_refresher()"

# Step 10: Test Bob's refresher and corefresher
print("\n~~~~ bob corefresher ~~~~")
cip10 = bob.encrypt(10)
a, b = cip10.corefresher(bob)
assert len(a) == 5, f"Error in ACESReader.corefresher(): corefresher dimension is not equal to n={5}"

for a_ in a:
    print(f"Level: {a_.lvl}, with encryption:", a_.enc)
    assert isinstance(a_, pyc.ACESCipher), "Error in ACESReader.corefresher()"

print(f"Level: {b.lvl}, with encryption:", b.enc)
assert isinstance(b, pyc.ACESCipher), "Error in ACESReader.corefresher()"
